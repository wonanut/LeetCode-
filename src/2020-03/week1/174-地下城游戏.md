LeetCode动态规划系列

# LeetCode174-地下城游戏

整理时间：2020年03月03日



### 1 题目描述

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。



**示例**

| -2(k) | -3   | 3     |
| ----- | ---- | ----- |
| -5    | -10  | 1     |
| 10    | 30   | -5(p) |

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。



### 2 题解

这个题应该属于那种你一看立马就应该有思路的类型，它得简化版类似于63-不同路径。

#### 本题陷阱

我第一时间想到的是dp[i] [j]设定为，走到坐标为（i，j）的格子里最少需要多少生命值，然后通过比较dp[i-1] [j]和dp[i] [j-1]的较小值，更新dp[i] [j]。但是这样不是完备的。这种想法不知不觉就落入了贪心陷阱！一条路，你的初始生命值只需要3，到(i,j)后生命值为1.另一条路，你的初始生命值需要4，到(i,j)后生命值为5.如果下一个点跟妖怪战斗消耗4.那么第一条路显然比第二条路需要更多生命值。但是第一条路确实是局部最优的。

| -2   | -1   | 5    |      |
| ---- | ---- | ---- | ---- |
| 0    | -10  | 3    |      |
| 1    | 0    | -1   | -4   |

上述情况类似于，dp[2] [2]会选择下下右右这条路，d[2] [2] = 3，但是由于到达(2,2)时生命值仅为1 ，而下一个点消耗4，则dp[2] [3] = 7 但是如果d[2] [2]选择右右下下 虽然d[2] [2] = 4 ,但是d [2] [3] = 4 小于第一种方法的7.

#### 逆向建立DP数组

反向建立dp数组。从公主那里算回起点。

dp[i] [j]数组意义为从(i,j)到达公主那所需的最小生命值，dp[i] [j]的状态变化方程如下：

```c++
dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);
//符合dp[i][j] + dungeon[i][j]>=min(dp[i+1][j]，dp[i][j+1]) 其实是这个公式的变形，和1比较是防止生命值掉为0或负数。
```

代码如下：

C++代码`

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int row = dungeon.size(),col = dungeon[0].size(); 
        if(row == 0) return 0;
        vector<vector<int > >dp.resize(row);
        for(int i=0;i<dp.size();i++)
            dp[i].resize(col);
        dp[row-1][col-1] = max(1,-dungeon[row-1][col-1]+1);
        //降生在公主处直接单挑魔王，最少需要多少生命值。跟1比较是防止没有魔王，是一个给你加血		的老实妖怪，你一感动带着负生命值去见它。
        for(int i= row-2;i>=0;i--)
            dp[i][col-1] = max(1,dp[i+1][col-1]-dungeon[i][col-1]);
        //初始化最后一行，只用考虑右边的格子
        for(int j=col-2;j>=0;j--)
            dp[row-1][j] = max(1,dp[row-1][j+1]-dungeon[row-1][j]);
        //初始化最后一列，只用考虑下面的格子
        for(int i=row-2;i>=0;i--){
            for(int j=col-2;j>=0;j--){
                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);
            }
        }
        return dp[0][0]; 
        //逆向建立dp数组返回dp[0][0]
    }
};
```



(完)

