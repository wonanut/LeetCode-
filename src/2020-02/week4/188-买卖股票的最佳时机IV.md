LeetCode动态规划系列

# LeetCode188-买卖股票的最佳时机

bunnybunnycat `动态规划` 

整理时间：2020年02月27日



### 1 题目描述

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**示例**

```cpp
输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```



*最佳买卖股票时机问题有很多变种：条件可能改变如下

- 对k的数值进行改变（如限定交易一次，限定交易两次，不限定交易次数）
- 加上限定条件，交易【冷冻期】，【手续费】（只影响dp状态变化公式）



### 2 题解

#### 2.1 递归

这种题目，一般建议使用自顶向下的递归方法求解，递归方法有如下优点

- 思维方式比较直接不饶弯
- 解决递归跳出条件和递归条件后，剩下的交给递归程序就完事

但是递归有一个严重的问题就是会重复计算，这是无法避免的开销，leecode上许多动态规划的题目的测试实例中设有陷阱，会让递归程序超时……下面贴出递归伪代码（k为无限，可无限次交易）如果k值为有限，可以在递归函数中加一个参数，再加上额外条件，很简单就不再赘述。

```cpp
int method(int status,vector<int> &prices) //status指的是现在手上有没有股票（有股票值为1）
{
	if(status == 1)
		return max(-prices[0]+method(0,prices[1,..]),method(status,prices[1,..]));
		//目前持有股票，今天要不卖出要不不卖
	else
		return max(+prices[0]+method(1,prices[0,..]),method(status,prices[1,..]));
		//目前没有股票，今天要不买要不不买
}
```

由于本题是要求尽量使用动态规划方法的，有关递归的内容就此打住，感兴趣的同学们可以试试上面的方法看看leecode有没有给递归设置陷阱……hhh



#### 2.2 动态规划

动态规划其实相当于给递归加上了缓冲区，当需要重复计算的时候，可以查表（其实就是查dp数组），这样相当于大大减少了递归深度。动态规划是一个自底向上得过程，所以难点就在于找到这个底！

##### 动态规划的基本步骤

- 抽象问题，确定一个底（由几个小问题组成的，边界是什么）
- 设计dp数组：dp数组的维度，dp数组的意义（存放的值代表什么）
- 设计dp数组状态改变公式（推荐学习一下状态机的概念）
- 初始化dp数组，解决一些特殊情况（在遍历前计算好）
- 本子上写伪代码 -> 通过熟悉的语言实现

回归本题，我们按照步骤一步一步来

1. 抽象问题：（尽量把问题缩小到最小）在任意一天，人可能有三个动作，买，卖，啥都不干。他们的边界是：（1啥也不干是没有限制的，每一天都可以啥都不干（2买是有限制的，如果手头有没有卖的股票就不可以再买，如果k值存在限制的话，交易k次后就不能买了（3卖也有限制，如果手头没有股票就没办法卖。我们根据上述问题抽象画出状态机。

   ![](C:\LeetCode-2020\src\2020-02\week4\images\123.png)

2. 设计dp数组：（1dp数组的维度：设定为三维的dp[][][i] [j] [k]：第一维天数，第二维为允许交易的次数，第三维手头有没有股票  （2dp数组的意义：在第i天操作之后赚了多少钱。tips：小技巧当你不知道怎么设置dp数组时就尽量把维度变大，当对问题清楚的时候可以适当减少维度。

3. 设计dp数组状态改变公式：联系步骤一中抽象出的问题，一天可进行的操作最多为两种，要不是买或啥都不干，要不是卖或啥都不干。区分这两种组合的边界是目前手上有没有股票，dp数组的第三维恰巧区分了这个边界。dp数组状态改变公式如下。 第一个公式意义为：今天手上没股票，要不是今天卖了要不是昨天开始就没有股票；第二个公式意义为：今天手上有股票，要不是今天买了股票，要不是昨天就有股票（今天啥都没干）

   ```cpp
   dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]);//i代表第i天；
   dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]);
   ```

   

4. 初始化dp数组：寻找特殊情况，(1 计算第一天收入时 (2 超过交易限制时

   ```cpp
   dp[1][j][0] = max(dp[0][j][0],dp[0][j][1]+prices[0]);
   dp[1][j][1] = max(dp[0][j][1],dp[0][j-1][0]-prices[0]);
   ```

   第一天的dp显然不可使用上述公式计算，因为dp[0] [j] [k]没有意义，所以可以加上一个条件，在第一天时使用下面的新公式：符合第一天的行为规则，要不买要不啥都不干。

   ```cpp
   dp[1][j][0] = 0;
   dp[1][j][1] = -prices[0]
   ```

   当交易次数超过限制时，就禁止购买，状态变化公式如下

   ```cpp
   dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]);；
   dp[i][j][1] = dp[i-1][j][1];//当前已经不允许交易了
   ```

   

   `C++代码`

   ```c++
   int methodDP(int k,vector<int>& prices) 
   {
   	vector<vector<vector<int> > >dp;
   	dp.resize(prices.size()+1);
   	for(int i=0;i<dp.size();i++)
   	{
   		dp[i].resize(k+1);
   		for(int j=0;j<dp[i].size();j++)
   		{
   			dp[i][j].resize(2);
   		}
   	}
   	for(int i=1;i<prices.size()+1;i++)
   	{
   		for(int j=0;j<k+1;j++)
   		{
   			if(i == 1)
   			{
   				dp[i][j][0] = 0;
   				dp[i][j][1] = - prices[i-1];
   			}
   			else
   			{
   				if(j==0)
   				{
   					dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1] - prices[i-1]);
   					dp[i][j][1] = dp[i-1][j][1];
   				}
   				else
   				{
   					dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1] + prices[i-1]);
   					dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0] - prices[i-1]);
   				}
   			}
   		}
   	}
   	return dp[prices.size()][k][0];
   }
   ```




### 总结

本问题的难点其实就在于提炼出一个边界状态（当前手头有没有股票）。找到这个状态量，量化，并围绕它建立dp数组，之后问题就会迎刃而解了。

### 参考

[1]: https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/

