LeetCode动态规划系列

# LeetCode132-分割回文串

bunnybunnycat`动态规划` 

整理时间：2020年02月29日



### 1 题目描述

给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。

返回符合要求的最少分割次数。

**示例**

```
输入: "aab"
输出: 1
解释: 进行一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```



### 2 题解

#### 2.1 递归

这种题目，一般建议使用自顶向下的递归方法求解，递归方法有如下优点

- 思维方式比较直接不饶弯
- 解决递归跳出条件和递归条件后，剩下的交给递归程序就完事

但是递归有一个严重的问题就是会重复计算，这是无法避免的开销，下面给出递归的伪代码。

```cpp
int method(string s) 
{
	if(s is 回文串)   //递归跳出条件
		return 1;
	min = method(s[0,0]) + method[1,s.size()-1];
	for(int i=1;i<s.size()-1;i++)
	{
		tmp = method(s[0,i]) + method[i+1.s.size()-1];
		if(tmp < min)
			min = tmp;
	}     //遍历，找到最少子串的组合，设置变量记下
	return min;  
}
```



#### 2.2 动态规划

动态规划其实相当于给递归加上了缓冲区，当需要重复计算的时候，可以查表（其实就是查dp数组），这样相当于大大减少了递归深度。动态规划是一个自底向上得过程，所以难点就在于找到这个底！

动态规划的基本步骤

- 抽象问题，确定一个底（由几个小问题组成的，边界是什么）
- 设计dp数组：dp数组的维度，dp数组的意义（存放的值代表什么）
- 设计dp数组状态改变公式（推荐学习一下状态机的概念）
- 初始化dp数组，解决一些特殊情况（在遍历前计算好）
- 本子上写伪代码 -> 通过熟悉的语言实现



回归本题，我们按照步骤一步一步来

1. 抽象问题：这个问题的底非常好想，其实就是把问题规模放小，比如两个元素的字符串怎么处理，三个怎么处理，但这个题在处理上可以说是完全没有捷径可走，对所有子串都是找到它内部的所有排列组合比较大小。

2. 设计dp数组：（1dp数组的维度：设定为一维的dp[][][i] ，i指向分割点 （2 dp数组的意义：以第i个元素作为分割点，前i个元素需要分割几次

3. 设计dp数组状态改变公式：本题的dp状态改变公式很简单

   ```cpp
   dp[i] = min(dp[j-1])+1	//限制条件(s[j,i]是回文串) j是s[0,i]子串的分割点
   ```
   
4. 初始化dp数组：寻找特殊情况

   (1) dp[0]的情况 
   
   ```cpp
   dp[0] = 0;  			//单个字符都是回文子串，不需要分割
   ```
   
   (2)  j 遍历到 j == 0的情况：如果s[j,i]是回文子串，dp[i] = 0
   
   

`C++代码`

```cpp
class Solution {
public:
    // 判断[start, end]之间的字符是否为回文串
    bool isPalindrome(string& s, int start, int end) {
        if (end - start < 0) return false;
        while (start < end) {
            if (s[start] != s[end]) return false;
            start ++;
            end --;
        } 
        return true;
    }

    int minCut(string s) {
        vector<int> dp(s.size());
        for (int i = 0; i < s.size(); i++) {
            if (isPalindrome(s, 0, i)) {
                dp[i] = 0;
                continue;
            }
            dp[i] = i;
            for (int j = 0; j < i; j++) {
                if (isPalindrome(s, j + 1, i)) { 
                    dp[i] = min(dp[j] + 1, dp[i]);
                }
            }
        }
        return dp[s.size() - 1];
    }
};
```



### 3 总结

本问题其实非常简单，基本上递归做一遍以后，对于动态规划该怎么做就有个初步的认识了，本题应尽量避免在dp数组设计上增加维度，这样反而会把思维带进死胡同，本题给dp数组增加维度对于理顺思路没有任何帮助~

