剑指Offer典型题整理 - 争取做最好的题解

# LeetCode42-接雨水

整理时间：2020年02月25日



### 1 题目描述

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

https://leetcode-cn.com/problems/trapping-rain-water/



**示例**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```



### 2 题解

这题一看就来者不善，滑动窗口好像不太管用，双指针又想不明白应该怎么用...

#### 2.1 一层一层计算

这是我看到这道题最先想到的做法，从下往上一层一层计算每层可以接的雨水，把结果累加起来不就好了，而且这样就可以直接使用对撞指针求解了！于是我高兴的写下如下代码，提交之后发现：`314 / 315 个通过测试用例`🙂，剩下的一个TLE了，看样子这个方法不太行呀。

`C++代码`

```cpp
#include <algorithm>
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() < 3) return 0;
        auto max_value = max_element(height.begin(), height.end());
        int ans = 0;
        for (int i = 1; i <= *max_value; i++) {
            int left = 0, right = height.size() - 1;
            while (height[left] < i) left ++;
            while (height[right] < i) right --;
            while (left < right) {
                if (height[left++] < i) ans += 1;
            }
        }
        return ans;
    }
};
```

*时间复杂度$O(m·n)$，n为数组中最大数字的值，空间复杂度$O(1)$。



#### 2.2 改进版本

其实这个问题并不需要完全套用滑动窗口的模板，可以利用题目特点将问题简化：

- 如果存在子串是p的异位词，那么该子串的长度一定和p相同
- 如果子串最右边的那个字母不在p中，那么该窗口可以直接向右平移。

`C++代码`

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        unordered_map<char, int> window;
        unordered_map<char, int> target;
        for (auto ch : p) target[ch] ++;

        int count = 0;
        int left = 0, right = 0;
        while (right < s.size()) {
            char rc = s[right];
            // 如果s[i]不在p中，直接将当前窗口向右平移
            if (target.count(rc) == 0) {
                left = right + 1;
                right = right + 1;
                window.clear();
                count = 0;
            }
            else {
                // right右移
                window[rc] ++;
                if (window[rc] == target[rc]) count ++;
                right ++;

                // left右移
                while (count == target.size()) {
                    if (right - left == p.size()) ans.push_back(left);
                    char lc = s[left];
                    if (target.count(lc)) {
                        window[lc] --;
                        if (window[lc] < target[lc]) count --;
                    }
                    left ++;
                }
            }
        }
        return ans;
    }
};
```

(完)