剑指Offer典型题整理 - 争取做最好的题解

# LeetCode55-跳跃游戏

整理时间：2020年02月22日



### 1 题目描述

给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。



**示例**

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```



### 2 题解

本题需要用到DP或者贪心思想，如果直接用回溯会超时。

#### 2.1 回溯

这是最暴力的解法，最差的时间复杂度为$O(2^n)$，会超时。不过对这个代码进行剪枝能通过，但没太大意义。

`C++代码`

```C++
#include <algorithm>

class Solution {
public:
    bool dfs(int cur, vector<int>& nums, vector<bool>& visited) {
        if (cur == nums.size() - 1) return true;

        int left = max(0, cur - nums[cur]);
        int right = min(int(nums.size() - 1), cur + nums[cur]);
        for(int i = right; i >= left; i--) {
            if (visited[i] == false) {
                visited[i] = true;
                bool ret = dfs(i, nums, visited);
                if (ret) return true;
                visited[i] = false;
            }
        }
        return false;
    }

    bool canJump(vector<int>& nums) {
        vector<bool> visited(nums.size());
        visited[0] = true;
        return dfs(0, nums, visited);
    }
};
```

#### 2.2 贪心

其实这个问题完全没有必要使用dfs，贪心思想就能够解决：如果能够从当前位置i移动最多k个位置，那么[i-k,i+k]这些范围就都能够到达，因此可以将这个问题

(完)